///////////////////////////////////////////////////////////////////////////////
version="$Id$";
category="Miscellaneous";
info="
LIBRARY:  mathml.lib    printing latex code

AUTHORS:  J. Boehm, boehm @ mathematik.uni-kl.de
          M. Mueller, mkmuelle @ mathematik.uni-kl.de
          H. Rombach, HRombach @ gmx.de
          M. Stein, maxstein77 @ web.de

OVERVIEW:

mathml conversion

KEYWORDS:
mathml



PROCEDURES:
mathml(def)                general procedure to generate a mathml code from a Singular object
viewMathml(string)         view mathml code
";

LIB "matrix.lib";



proc mod_init()
{
LIB "methods.lib";
HashTable F = hashTable(list(list("ring"),list("matrix"),list("int"),list("string")),list("mathmlRing","mathmlMatrix","mathmlInt","mathmlString"));
Method mathml_ = method(F);
export(mathml_); 
// export is broken in Singular at the moment, does not work for newstructs, so mathml_ is not available, however the function tex works
installMethod(mathml_,"tex");
}


proc mathmlMatrix(matrix m){
 string s;
 int i=1;
 int j=1;
 s=s+"<math xmlns=http://www.w3.org/1998/Math/MathML><!doctype html> <mfenced open=[ close=]> <mtable>";
  while (i<=nrows(m)) {
   j=1;
    s=s+"<mtr>";
    while (j<=ncols(m)) {
      s=s+"<mtd> <mi>"+string(m[i,j])+"</mi></mtd>";
      j=j+1;
     }
     s=s+"</mtr>";
    i=i+1;
  }
return(s);
}

proc mathmlInt(matrix m){}

proc mathmlString(matrix m){}

proc LeadCoef(string s) {
string t;
int i=1;
int u=0;
 while (i<size(s)) {
   if (s[i]=="/")  {u=1;
                    i=size(s);} 
   i=i+1;
  }
i=1;
if (u==1) {
   if (s[1]=="-") {
   t="<mo>-</mo>";
   i=2;}
   t=t+"<mfrac> <mn>";
 while (i<=size(s)) {
    if (s[i]=="/") {t=t+"</mn> <mn>";} 
    else           {t=t+s[i];}
    i=i+1;
    }
   t=t+"</mn> </mfrac>";
  }
if (u==0) {t="<mn>"+s+"</mn>";}
return(t);
} 

proc Sort(string s,string z){
string g;
string z2=z+",;";
 while (z2!=";") {
  if (find(s,z2[1,find(z2,",")-1])!=0) {
   g=g+z2[1,find(z2,",")];
   }
 z2=z2[find(z2,",")+1,size(z2)-find(z2,",")];
}
g=g[1,size(g)-1];
return(g);
}      

proc mathmlMonomial(string s,string z){
 string g;
 string t=Sort(s,z)+",;,";
 string s2=s+";"; 
 string v=t[1,find(t,",")-1];
 string v2;
 while (v!=";") {
  g=g+"<msup><mi>"+v+"</mi>";
  t=t[size(v)+2,size(t)-size(v)-1];
  v2=t[1,find(t,",")-1];
  g=g+"<mn>"+s2[size(v)+1,find(s2,v2)-size(v)-1]+"</mn></msup>";
  s2=s2[find(s2,v2),size(s2)-find(s2,v2)+1];
  v=v2;
  }
return(g);
}

proc mathmldelete(string z,string a) {
 string g=z+";";
 while (find(g,a)!=0) {
  g=g[1,find(g,a)-1]+g[find(g,a)+1,size(g)-find(g,a)];
  }
 g=g[1,size(g)-1];
 return(g);
}



proc mathmlTransform(string z,string t1,string t2) {
string g=z+";";
 while (find(g,t1)!=0) {
  g=g[1,find(g,t1)-1]+t2+g[find(g,t1)+size(t1),size(g)-find(g,t1)-size(t1)+1];
 }
return(g);
}

proc mathprob (poly a,def r){
poly d=leadcoef(a);
list l12=ringlist(basering);
for(int i=1;i<=size(l12[1][2]);i++) {
l12[2][i]=l12[1][2][i]+"1";
l12[1][2][i]=l12[1][2][i]+"0";
}
def w=ring(l12);
setring(w);
keepring w;
poly f=fetch(r,d);
print(basering);
list l12=ringlist(basering);
for (i=1;i<=size(l12[1][2]);i++) {
f=subst(f,par(i),var(i));
}
while (size(l12[2])>size(l12[1][2])) {
 l12[2]=delete(l12[2],size(l12[1][2])+1);
 }
for (i=1;i<=size(l12[2]);i++) {
l12[2][i]=l12[2][i][1,size(l12[2][i])-1];
 }
l12[1]=ringlist(r)[1][1];
print(l12);
def w2=ring(l12);
keepring w2;
poly f=fetch(w,f);
return(f);
}

proc mathmlPoly(string s,string z){
string g;
string s2=s;
string z2;
string s1=s+";";
int v;
while (s1!=";") {
if (s1[1]=="+") {g=g+"<mo>+</mo>";s1=s1[2,size(s1)-1];}
if (s1[1]=="-") {g=g+"<mo>-</mo>";s1=s1[2,size(s1)-1];}
v=size(s1);
if (find(s1,"+")>0) {v=find(s1,"+");}
if (find(s1,"-")>0 && find(s1,"-")<v) {v=find(s1,"-");}
s2=s1[1,v-1];
z2=Sort(s2,z);
g=g+LeadCoef(s2[1,find(s2,z2[1])-1]);
g=g+mathmlMonomial(s2[find(s2,z2[1]),size(s2)-find(s2,z2[1])+1],z2);
s1=s1[find(s1,s2)+size(s2),size(s1)-find(s1,s2)-size(s2)+1];
}
return(g);
}

proc mathmlPolynom(poly m,def r) {
string g="<math xmlns=http://www.w3.org/1998/Math/MathML>";ring r2=0,x,lp;
poly d=m; 
string d1; 
int h; 
 while (d!=0) {
  d1=mathmldelete(string(d),"*");
  h=size(string(leadcoef(d)))-find(string(d),")");
  if (d1[1]=="(") {
   if (h>0) {g=g+"<mfrac><mrow>";}
   else     {g=g+"<mo>(</mo>";}
   g=g+mathmlPoly(d1[2,find(d1,")")-2],string(ringlist(r)[1][2]));
  if (h>0) {g=g+"</mrow><mn>"+d1[find(d1,")")+2,h-1]+"</mn></mfrac>";}
  else     {g=g+"<mo>)</mo>";}
  }
  else { 
   g=g+LeadCoef(string(leadcoef(d)));}
  g=g+mathmlMonomial(string(leadmonom(d)),string(variables(d)));
 d=d-lead(d);
 if (d!=0 && string(leadcoef(d))[1]!="-") {
   g=g+"<mo>+</mo>";
  }
 }
return(g);
}


proc mathmlRing(def r){
int i=0;
string t;
string s="<math xmlns=http://www.w3.org/1998/Math/MathML>";
 if (string(r)[2]=="0") {
  s=s+"<mi> Q";
  }
  if (string(r)[2]!="0") {
   t=string(r)[2,find(string(r),",")-2];
   s=s+"<msub><mi>Z</mi><mn>"+t+"</mn></msub>";
  }
 if (find(string(r),")")>find(string(r),","))  {
  t=string(r)[find(string(r),",")+1,size(string(r))];
  t=t[1,find(t,")")-1];
  s=s+"["+t+"]";
  s=s+"/"+string(ringlist(r)[1][4])+" ";
 }
  t=string(r)[find(string(r),")")+3,size(string(r))];
  s=s+"["+t[1,find(t,")")-1];
  s=s+"] </mi>";
s=s+"</math>";
return(s);
}

// usw
